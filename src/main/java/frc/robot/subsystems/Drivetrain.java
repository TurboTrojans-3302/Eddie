// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import com.kauailabs.navx.frc.AHRS;
import com.swervedrivespecialties.swervelib.Mk4SwerveModuleHelper;
import com.swervedrivespecialties.swervelib.Mk4SwerveModuleHelper.GearRatio;
import com.swervedrivespecialties.swervelib.SwerveModule;

import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.math.kinematics.SwerveDriveKinematics;
import edu.wpi.first.math.kinematics.SwerveModuleState;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.RobotMap;
import frc.robot.commands.TeleOPDrive;

/**
 *
 */
public class Drivetrain extends SubsystemBase {
    private static final double TRACKWIDTH = 19.5;
    private static final double WHEELBASE = 23.5;
    private static final double MAX_SPEED = 1.5; // m/s

    private static final double FRONT_LEFT_ANGLE_OFFSET = -Math.toRadians(0.0);
    private static final double FRONT_RIGHT_ANGLE_OFFSET = -Math.toRadians(0.0);
    private static final double BACK_LEFT_ANGLE_OFFSET = -Math.toRadians(0.0);
    private static final double BACK_RIGHT_ANGLE_OFFSET = -Math.toRadians(0.0);

    private static Drivetrain instance;

    private final SwerveModule frontLeftModule = Mk4SwerveModuleHelper.createNeo(
                                                        GearRatio.L2,
                                                        RobotMap.DRIVETRAIN_FRONT_LEFT_DRIVE_MOTOR,
                                                        RobotMap.DRIVETRAIN_FRONT_LEFT_ANGLE_MOTOR,
                                                        RobotMap.DRIVETRAIN_FRONT_LEFT_ANGLE_ENCODER,
                                                        FRONT_LEFT_ANGLE_OFFSET );
    private final SwerveModule frontRightModule = Mk4SwerveModuleHelper.createNeo(
                                                        GearRatio.L2,
                                                        RobotMap.DRIVETRAIN_FRONT_RIGHT_DRIVE_MOTOR,
                                                        RobotMap.DRIVETRAIN_FRONT_RIGHT_ANGLE_MOTOR,
                                                        RobotMap.DRIVETRAIN_FRONT_RIGHT_ANGLE_ENCODER,
                                                        FRONT_RIGHT_ANGLE_OFFSET );

    private final SwerveModule backLeftModule = Mk4SwerveModuleHelper.createNeo(
                                                        GearRatio.L2,
                                                        RobotMap.DRIVETRAIN_BACK_LEFT_DRIVE_MOTOR,
                                                        RobotMap.DRIVETRAIN_BACK_LEFT_ANGLE_MOTOR,
                                                        RobotMap.DRIVETRAIN_BACK_LEFT_ANGLE_ENCODER,
                                                        BACK_LEFT_ANGLE_OFFSET );

    private final SwerveModule backRightModule = Mk4SwerveModuleHelper.createNeo(
                                                        GearRatio.L2,
                                                        RobotMap.DRIVETRAIN_BACK_RIGHT_DRIVE_MOTOR,
                                                        RobotMap.DRIVETRAIN_BACK_RIGHT_ANGLE_MOTOR,
                                                        RobotMap.DRIVETRAIN_BACK_RIGHT_ANGLE_ENCODER,
                                                        BACK_RIGHT_ANGLE_OFFSET );
                        
                        

    private final SwerveDriveKinematics kinematics = new SwerveDriveKinematics(
            new Translation2d(TRACKWIDTH / 2.0, WHEELBASE / 2.0),
            new Translation2d(TRACKWIDTH / 2.0, -WHEELBASE / 2.0),
            new Translation2d(-TRACKWIDTH / 2.0, WHEELBASE / 2.0),
            new Translation2d(-TRACKWIDTH / 2.0, -WHEELBASE / 2.0)
    );

    private final AHRS ahrs = new AHRS();

    public Drivetrain() {
        ahrs.calibrate();

        setDefaultCommand(new TeleOPDrive(this));
    }

    public static Drivetrain getInstance() {
        if (instance == null) {
            instance = new Drivetrain();
        }

        return instance;
    }

    @Override
    public void periodic() {

        SmartDashboard.putNumber("Front Left Module Angle", Math.toDegrees(frontLeftModule.getSteerAngle()));
        SmartDashboard.putNumber("Front Right Module Angle", Math.toDegrees(frontRightModule.getSteerAngle()));
        SmartDashboard.putNumber("Back Left Module Angle", Math.toDegrees(backLeftModule.getSteerAngle()));
        SmartDashboard.putNumber("Back Right Module Angle", Math.toDegrees(backRightModule.getSteerAngle()));

        SmartDashboard.putNumber("Gyroscope Angle", ahrs.getYaw());

    }

    public void drive(Translation2d translation, double rotation, boolean fieldOriented) {
        rotation *= 2.0 / Math.hypot(WHEELBASE, TRACKWIDTH);
        ChassisSpeeds speeds;
        if (fieldOriented) {
            speeds = ChassisSpeeds.fromFieldRelativeSpeeds(translation.getX(), translation.getY(), rotation,
                    Rotation2d.fromDegrees(ahrs.getAngle()));
        } else {
            speeds = new ChassisSpeeds(translation.getX(), translation.getY(), rotation);
        }

        SwerveModuleState[] states = kinematics.toSwerveModuleStates(speeds);
        frontLeftModule.set(states[0].speedMetersPerSecond/MAX_SPEED, states[0].angle.getRadians());
        frontRightModule.set(states[1].speedMetersPerSecond/MAX_SPEED, states[1].angle.getRadians());
        backLeftModule.set(states[2].speedMetersPerSecond/MAX_SPEED, states[2].angle.getRadians());
        backRightModule.set(states[3].speedMetersPerSecond/MAX_SPEED, states[3].angle.getRadians());
        //TODO we'd really like to set the velocity in m/s
    }

    public void resetGyroscope() {
        ahrs.setAngleAdjustment(ahrs.getAngle() - ahrs.getAngleAdjustment());
    }

}

