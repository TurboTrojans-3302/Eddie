// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import com.fasterxml.jackson.core.TreeNode;
import com.kauailabs.navx.frc.AHRS;
import com.swervedrivespecialties.swervelib.ModuleConfiguration;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.math.kinematics.SwerveDriveKinematics;
import edu.wpi.first.math.kinematics.SwerveModuleState;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.RobotMap;
import frc.robot.commands.TeleOPDrive;

/**
 *
 */
public class Drivetrain extends SubsystemBase {
    private static final double TRACKWIDTH = 19.5 * 0.0254; //distance between the left and right wheels
    private static final double WHEELBASE = 23.5 * 0.0254; //front to back distance
    private static final double MAX_SPEED = 3.0; // m/s 

    private static final double FRONT_LEFT_ANGLE_OFFSET = Math.toRadians(29.8);
    private static final double FRONT_RIGHT_ANGLE_OFFSET = Math.toRadians(151.3);
    private static final double BACK_LEFT_ANGLE_OFFSET = Math.toRadians(124.4);
    private static final double BACK_RIGHT_ANGLE_OFFSET = Math.toRadians(341.6);

    private static Drivetrain instance;

    ModuleConfiguration rightSideConfiguration = new ModuleConfiguration(
        0.10033,
        (14.0 / 50.0) * (27.0 / 17.0) * (15.0 / 45.0),
        true,
        (9.0 / 24.0) * (14.0 / 72.0),
        true );

    ModuleConfiguration leftSideConfiguration = new ModuleConfiguration(
        0.10033,
        (14.0 / 50.0) * (27.0 / 17.0) * (15.0 / 45.0),
        false,
        (9.0 / 24.0) * (14.0 / 72.0),
        true );
    
        private final TTSwerveModule frontLeftModule = new TTSwerveModule(
                                                        leftSideConfiguration,
                                                        RobotMap.DRIVETRAIN_FRONT_LEFT_DRIVE_MOTOR,
                                                        RobotMap.DRIVETRAIN_FRONT_LEFT_ANGLE_MOTOR,
                                                        RobotMap.DRIVETRAIN_FRONT_LEFT_ANGLE_ENCODER,
                                                        FRONT_LEFT_ANGLE_OFFSET );
    private final TTSwerveModule frontRightModule = new TTSwerveModule(
                                                        rightSideConfiguration,
                                                        RobotMap.DRIVETRAIN_FRONT_RIGHT_DRIVE_MOTOR,
                                                        RobotMap.DRIVETRAIN_FRONT_RIGHT_ANGLE_MOTOR,
                                                        RobotMap.DRIVETRAIN_FRONT_RIGHT_ANGLE_ENCODER,
                                                        FRONT_RIGHT_ANGLE_OFFSET );

    private final TTSwerveModule backLeftModule  = new TTSwerveModule(
                                                        leftSideConfiguration,
                                                        RobotMap.DRIVETRAIN_BACK_LEFT_DRIVE_MOTOR,
                                                        RobotMap.DRIVETRAIN_BACK_LEFT_ANGLE_MOTOR,
                                                        RobotMap.DRIVETRAIN_BACK_LEFT_ANGLE_ENCODER,
                                                        BACK_LEFT_ANGLE_OFFSET );

    private final TTSwerveModule backRightModule =  new TTSwerveModule(
                                                        rightSideConfiguration,
                                                        RobotMap.DRIVETRAIN_BACK_RIGHT_DRIVE_MOTOR,
                                                        RobotMap.DRIVETRAIN_BACK_RIGHT_ANGLE_MOTOR,
                                                        RobotMap.DRIVETRAIN_BACK_RIGHT_ANGLE_ENCODER,
                                                        BACK_RIGHT_ANGLE_OFFSET );
                        
                        
    private final SwerveDriveKinematics kinematics = new SwerveDriveKinematics(
            new Translation2d(-WHEELBASE / 2.0, TRACKWIDTH / 2.0),  //front left
            new Translation2d(-WHEELBASE / 2.0, -TRACKWIDTH / 2.0), //front right
            new Translation2d(WHEELBASE / 2.0, TRACKWIDTH / 2.0), //back  left
            new Translation2d(WHEELBASE / 2.0, -TRACKWIDTH / 2.0) //back  right
    );

    private final AHRS ahrs = new AHRS();

    public Drivetrain() {
        ahrs.calibrate();

        setDefaultCommand(new TeleOPDrive(this));
    }

    public static Drivetrain getInstance() {
        if (instance == null) {
            instance = new Drivetrain();
        }

        return instance;
    }

    @Override
    public void periodic() {

        SmartDashboard.putNumber("Front Left Module Angle", Math.toDegrees(frontLeftModule.getSteerAngle()));
        SmartDashboard.putNumber("Front Right Module Angle", Math.toDegrees(frontRightModule.getSteerAngle()));
        SmartDashboard.putNumber("Back Left Module Angle", Math.toDegrees(backLeftModule.getSteerAngle()));
        SmartDashboard.putNumber("Back Right Module Angle", Math.toDegrees(backRightModule.getSteerAngle()));
        SmartDashboard.putNumber("Back Right Module Absolute Angle", Math.toDegrees(backRightModule.getAbsoluteAngle()));
        SmartDashboard.putNumber("Back left Module Absolute Angle", Math.toDegrees(backLeftModule.getAbsoluteAngle()));
        SmartDashboard.putNumber("front left Module Absolute Angle", Math.toDegrees(frontLeftModule.getAbsoluteAngle()));
        SmartDashboard.putNumber("front Right Module Absolute Angle", Math.toDegrees(frontRightModule.getAbsoluteAngle()));
        SmartDashboard.putNumber("Gyroscope Angle", ahrs.getYaw());
    }

    public void drive(Translation2d translation, double rotation, boolean fieldOriented) {

        translation = translation.times(MAX_SPEED);
        rotation *= 2.0 / Math.hypot(WHEELBASE, TRACKWIDTH);
        ChassisSpeeds speeds;
        if (fieldOriented) {
            speeds = ChassisSpeeds.fromFieldRelativeSpeeds(translation.getX(), translation.getY(), rotation,
                    Rotation2d.fromDegrees(ahrs.getAngle()));
        } else {
            speeds = new ChassisSpeeds(translation.getX(), translation.getY(), rotation);
        }


        SwerveModuleState[] states = kinematics.toSwerveModuleStates(speeds);
        frontLeftModule.set(states[0].speedMetersPerSecond, states[0].angle.getRadians());
        frontRightModule.set(states[1].speedMetersPerSecond, states[1].angle.getRadians());
        backLeftModule.set(states[2].speedMetersPerSecond, states[2].angle.getRadians());
        backRightModule.set(states[3].speedMetersPerSecond, states[3].angle.getRadians());
        //TODO we'd really like to set the velocity in m/s

        SmartDashboard.putNumber("Front Left Commanded Angle", states[0].angle.getDegrees());
        SmartDashboard.putNumber("Front Right Commanded Angle", states[1].angle.getDegrees());
        SmartDashboard.putNumber("Back Left Commanded Angle", states[2].angle.getDegrees());
        SmartDashboard.putNumber("Back Right Commanded Angle", states[3].angle.getDegrees());
    }
    
    public void setAll(double speed, double angleRadians) {
        frontLeftModule.set(speed, angleRadians);
        frontRightModule.set(speed, angleRadians);
        backLeftModule.set(speed, angleRadians);
        backRightModule.set(speed, angleRadians);
        SmartDashboard.putNumber("Front Left Commanded Angle", Math.toDegrees(angleRadians));
        SmartDashboard.putNumber("Front Right Commanded Angle", Math.toDegrees(angleRadians));
        SmartDashboard.putNumber("Back Left Commanded Angle", Math.toDegrees(angleRadians));
        SmartDashboard.putNumber("Back Right Commanded Angle", Math.toDegrees(angleRadians));
    }


    public void resetGyroscope() {
        ahrs.setAngleAdjustment(ahrs.getAngle() - ahrs.getAngleAdjustment());
    }

    public double getPitch() {
       return ahrs.getPitch();
    }

    public void calibrateSterrRelativeEncoder(){
        frontLeftModule.calibrateSterrRelativeEncoder();
        frontRightModule.calibrateSterrRelativeEncoder();
        backLeftModule.calibrateSterrRelativeEncoder();
        backRightModule.calibrateSterrRelativeEncoder();
    }
}

//TODO Create a stop method for the drivetrain